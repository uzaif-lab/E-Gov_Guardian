"""
Additional vulnerability detection modules
"""

import re
import ssl
import socket
import subprocess
import hashlib
import os
import nmap
import requests
from typing import Dict, List, Any, Optional
from urllib.parse import urlparse, urljoin
import logging
from bs4 import BeautifulSoup

class VulnerabilityDetector:
    """Additional vulnerability detection beyond ZAP"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.nm = nmap.PortScanner()
        
    def check_insecure_headers(self, url: str) -> Dict[str, Any]:
        """Check for missing security headers"""
        security_headers = {
            'X-Frame-Options': 'Missing clickjacking protection',
            'X-Content-Type-Options': 'Missing MIME type sniffing protection',
            'X-XSS-Protection': 'Missing XSS protection',
            'Strict-Transport-Security': 'Missing HTTPS enforcement',
            'Content-Security-Policy': 'Missing CSP protection',
            'Referrer-Policy': 'Missing referrer policy',
            'Permissions-Policy': 'Missing permissions policy'
        }
        
        missing_headers = []
        response_headers = {}
        
        try:
            response = requests.get(url, timeout=10, verify=False)
            response_headers = dict(response.headers)
            
            for header, description in security_headers.items():
                if header not in response.headers:
                    missing_headers.append({
                        'header': header,
                        'description': description,
                        'severity': 'Medium'
                    })
                    
        except requests.RequestException as e:
            self.logger.error(f"Error checking headers for {url}: {str(e)}")
            
        return {
            'missing_headers': missing_headers,
            'response_headers': response_headers,
            'total_missing': len(missing_headers)
        }
    
    def check_insecure_cookies(self, url: str) -> Dict[str, Any]:
        """Check for insecure cookie configurations"""
        insecure_cookies = []
        
        try:
            response = requests.get(url, timeout=10)
            
            for cookie in response.cookies:
                issues = []
                
                if not cookie.secure:
                    issues.append("Missing Secure flag")
                    
                # Check for HttpOnly (requests doesn't expose this directly)
                cookie_header = response.headers.get('Set-Cookie', '')
                if 'HttpOnly' not in cookie_header:
                    issues.append("Missing HttpOnly flag")
                    
                if 'SameSite' not in cookie_header:
                    issues.append("Missing SameSite attribute")
                    
                if issues:
                    insecure_cookies.append({
                        'name': cookie.name,
                        'domain': cookie.domain,
                        'issues': issues,
                        'severity': 'Medium'
                    })
                    
        except requests.RequestException as e:
            self.logger.error(f"Error checking cookies for {url}: {str(e)}")
            
        return {
            'insecure_cookies': insecure_cookies,
            'total_issues': len(insecure_cookies)
        }
    
    def check_ssl_configuration(self, hostname: str, port: int = 443) -> Dict[str, Any]:
        """Check SSL/TLS configuration"""
        ssl_issues = []
        
        try:
            context = ssl.create_default_context()
            
            with socket.create_connection((hostname, port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as secure_sock:
                    cert = secure_sock.getpeercert()
                    cipher = secure_sock.cipher()
                    
                    # Check SSL version
                    if secure_sock.version() in ['SSLv2', 'SSLv3', 'TLSv1', 'TLSv1.1']:
                        ssl_issues.append({
                            'issue': f"Weak SSL/TLS version: {secure_sock.version()}",
                            'severity': 'High'
                        })
                    
                    # Check cipher strength
                    if cipher and cipher[2] < 128:
                        ssl_issues.append({
                            'issue': f"Weak cipher: {cipher[0]} ({cipher[2]} bits)",
                            'severity': 'Medium'
                        })
                        
        except Exception as e:
            ssl_issues.append({
                'issue': f"SSL connection failed: {str(e)}",
                'severity': 'High'
            })
            
        return {
            'ssl_issues': ssl_issues,
            'total_issues': len(ssl_issues)
        }
    
    def scan_open_ports(self, host: str, port_list: List[int]) -> Dict[str, Any]:
        """Scan for open ports"""
        open_ports = []
        
        try:
            # Convert port list to string for nmap
            port_range = ','.join(map(str, port_list))
            
            self.nm.scan(host, port_range, arguments='-sS')
            
            for host_scanned in self.nm.all_hosts():
                for protocol in self.nm[host_scanned].all_protocols():
                    ports = self.nm[host_scanned][protocol].keys()
                    
                    for port in ports:
                        state = self.nm[host_scanned][protocol][port]['state']
                        if state == 'open':
                            service = self.nm[host_scanned][protocol][port].get('name', 'unknown')
                            version = self.nm[host_scanned][protocol][port].get('version', '')
                            
                            # Determine risk level based on service
                            risk_level = self._assess_port_risk(port, service)
                            
                            open_ports.append({
                                'port': port,
                                'protocol': protocol,
                                'service': service,
                                'version': version,
                                'risk_level': risk_level
                            })
                            
        except Exception as e:
            self.logger.error(f"Port scan error: {str(e)}")
            
        return {
            'open_ports': open_ports,
            'total_open': len(open_ports),
            'high_risk_ports': [p for p in open_ports if p['risk_level'] == 'High']
        }
    
    def _assess_port_risk(self, port: int, service: str) -> str:
        """Assess risk level of open port"""
        high_risk_ports = [21, 23, 135, 139, 445, 1433, 3389]  # FTP, Telnet, RPC, NetBIOS, SMB, SQL Server, RDP
        medium_risk_ports = [22, 25, 53, 110, 143, 993, 995]   # SSH, SMTP, DNS, POP3, IMAP
        
        if port in high_risk_ports:
            return 'High'
        elif port in medium_risk_ports:
            return 'Medium'
        else:
            return 'Low'
    
    def check_outdated_libraries(self, source_code_path: str) -> Dict[str, Any]:
        """Check for outdated libraries in source code"""
        outdated_libs = []
        
        # Look for common dependency files
        dependency_files = [
            'requirements.txt', 'package.json', 'composer.json', 
            'Gemfile', 'pom.xml', 'build.gradle'
        ]
        
        for root, dirs, files in os.walk(source_code_path):
            for file in files:
                if file in dependency_files:
                    file_path = os.path.join(root, file)
                    try:
                        with open(file_path, 'r', encoding='utf-8') as f:
                            content = f.read()
                            # This is a simplified check - in production, you'd use 
                            # specific parsers for each dependency format
                            outdated_libs.extend(self._parse_dependencies(file, content))
                    except Exception as e:
                        self.logger.error(f"Error reading {file_path}: {str(e)}")
        
        return {
            'outdated_libraries': outdated_libs,
            'total_outdated': len(outdated_libs)
        }
    
    def _parse_dependencies(self, filename: str, content: str) -> List[Dict[str, Any]]:
        """Parse dependency files for outdated libraries"""
        # This is a simplified implementation
        # In production, you would use specialized parsers and vulnerability databases
        
        outdated = []
        
        if filename == 'requirements.txt':
            lines = content.split('\n')
            for line in lines:
                line = line.strip()
                if line and not line.startswith('#'):
                    if '==' in line:
                        package, version = line.split('==')
                        # Example check - in production, check against vulnerability DB
                        if self._is_version_outdated(package.strip(), version.strip()):
                            outdated.append({
                                'package': package.strip(),
                                'current_version': version.strip(),
                                'file': filename,
                                'severity': 'Medium'
                            })
        
        return outdated
    
    def _is_version_outdated(self, package: str, version: str) -> bool:
        """Check if package version is outdated (simplified)"""
        # In production, this would check against vulnerability databases
        # like CVE, NVD, or package-specific security advisories
        
        known_vulnerable = {
            'django': ['1.11.0', '2.0.0', '2.1.0'],
            'flask': ['0.12.0', '1.0.0'],
            'requests': ['2.19.0', '2.20.0']
        }
        
        return package.lower() in known_vulnerable and version in known_vulnerable[package.lower()]
    
    def basic_malware_check(self, file_path: str) -> Dict[str, Any]:
        """Basic malware/ransomware behavior check"""
        suspicious_indicators = []
        
        if not os.path.exists(file_path):
            return {'error': 'File not found'}
        
        try:
            # Check file hash against known malware hashes (simplified)
            file_hash = self._calculate_file_hash(file_path)
            
            # Check file extension
            _, ext = os.path.splitext(file_path)
            suspicious_extensions = ['.exe', '.dll', '.bat', '.cmd', '.scr', '.pif', '.com']
            
            if ext.lower() in suspicious_extensions:
                suspicious_indicators.append({
                    'indicator': f'Suspicious file extension: {ext}',
                    'severity': 'Medium'
                })
            
            # Check file content for suspicious strings
            try:
                with open(file_path, 'rb') as f:
                    content = f.read(1024 * 1024)  # Read first 1MB
                    suspicious_strings = [
                        b'encrypt', b'decrypt', b'ransom', b'bitcoin',
                        b'crypto', b'payload', b'shell', b'backdoor'
                    ]
                    
                    for suspicious in suspicious_strings:
                        if suspicious in content.lower():
                            suspicious_indicators.append({
                                'indicator': f'Contains suspicious string: {suspicious.decode()}',
                                'severity': 'High'
                            })
                            
            except Exception:
                pass  # Binary file or permission issue
                
        except Exception as e:
            return {'error': f'Analysis failed: {str(e)}'}
        
        return {
            'file_path': file_path,
            'file_hash': file_hash,
            'suspicious_indicators': suspicious_indicators,
            'risk_level': 'High' if any(i['severity'] == 'High' for i in suspicious_indicators) else 'Low'
        }
    
    def _calculate_file_hash(self, file_path: str) -> str:
        """Calculate SHA256 hash of file"""
        sha256_hash = hashlib.sha256()
        
        try:
            with open(file_path, 'rb') as f:
                for chunk in iter(lambda: f.read(4096), b""):
                    sha256_hash.update(chunk)
        except Exception:
            return 'unknown'
            
        return sha256_hash.hexdigest() 